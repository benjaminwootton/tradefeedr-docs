= Execution Stats

== Introduction

The `v1/fx/rfs/execution-stats` endpoint is designed to study general execution quality of the trades and their associated market impact. 

For example, in the notebook we show how you can use this endpoint to create a venue analysis. 
It includes the summarised spread paid and market impact generated by different liquidity providers split by the different platforms/ECNs the user trades on.

The endpoint allows you to query across the entire execution history. The query returns a table with the metrics (fields) selected by the user as columns. The rows are defined by `groupby` statements. 



== API Specification

The API endpoint requires a JSON object representing query logic similar to SQL and containing the following fields:

* `groupby` - which fields the results will be aggregated by
* `select`  - which fields should be returned in the end result. For example `SpreadPnLPM`. The full list of possible values is given below 
* `filter`  - how the underlying data should be filtered


== Examples 

**Note**: For display purposes we have limited the number of rows to 5 and and columns to 10.

=== Only `LP` in `groupby`
---

Refer to xref:api_rfs/api_rfs.adoc[RFS API] page for page for details on aggregation logic.

**Note:** Aggregation is different depending on `select` and `groupby` fields

In the example below we groupby `LP`, numerical fields such as `Price`,`Mid0` return `None` as we aggregate across `Symbol` and `Side`. 
The aggregation of these results do not return a meaningful result.

====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats.py[]
----
====

==== Results
---
image::api_rfs/execution_stats/api_rfs_execution_stats_ex1.png["api_rfs_execution_stats_ex1.png"]


=== Only `Symbol` and `Side` in `groupby`
---

Refer to xref:api_rfs/api_rfs.adoc[API RFS] page for page for details on aggregation logic.

In this case as we are applying a `groupby` by `Symbol` and `Side`.`Price` and `Mid0` are specified in `select` query and they are returned as weighted average across `groupby` categories with `TradeQuantityUSD` being the weights. In this case the results are not `None` as we are not aggregating across different `Symbol` and `Side` values.

`ExecVenue` and `LP` are still returned as `None` because there is not consistent way to aggregate symbolic variable such as `ExecVenue` or `LP` across e.g. all EURUSD trades. 


====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex2.py[]
----
====

==== Results
---
image::api_rfs/execution_stats/api_rfs_execution_stats_ex2.png["api_rfs_execution_stats_ex2.png"]

=== Spread Paid and Market Impact
---
In this example we conduct a venue analysis where we group the results by `LP`, `ExecVenue`, `Symbol` and `OrderStatus` . This is to review the overall quality of the liquidity of each LP across the different platforms/ECNs.
It is also important what the market does after fill. `DecayPM1s` measures side-adjusted move in $/m. 

Positive number means that that market mid goes up after buy fill and down after sell fill.
Grouping by `OrderStatus` allows you to differentiate the markout curves between filled and rejected trades.


====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex3.py[]
----
====


==== Results
---
image::api_rfs/execution_stats/api_rfs_execution_stats_ex3.png["api_rfs_execution_stats_ex3.png"]

==== Figure
---

====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex3_fig.py[]
----
====

++++
<div id='chart1'></div>
<script>
	d3.csv("../_attachments/api_rfs/execution_stats/raw/api_rfs_execution_stats_ex3.csv").then((data) => {
		var selected = 'USDCAD';
		const res = data.filter(({
		  Symbol
		}) => selected.includes(Symbol));
		var trace1 = [{
				x: res.map((column) => column.LP),
				y: res.map((column) => column.SpreadPnLPM),
                mode: 'markers',
				type: 'scatter',
				name: 'USDCAD'
		}]
        
		var selected = 'USDNOK';
		const res1 = data.filter(({
		  Symbol
		}) => selected.includes(Symbol));
		var trace2 = [{
				x: res1.map((column) => column.LP),
				y: res1.map((column) => column.SpreadPnLPM),
                mode: 'markers',
				type: 'scatter',
				name: 'USDNOK'
		}]

		var selected = 'USDCHF';
		const res2 = data.filter(({
		  Symbol
		}) => selected.includes(Symbol));
		var trace3 = [{
				x: res2.map((column) => column.LP),
				y: res2.map((column) => column.SpreadPnLPM),
                mode: 'markers',
				type: 'scatter',
				name: 'USDCHF'
		}]
        
		var selected = 'USDJPY';
		const res3 = data.filter(({
		  Symbol
		}) => selected.includes(Symbol));
		var trace4 = [{
				x: res3.map((column) => column.LP),
				y: res3.map((column) => column.SpreadPnLPM),
                mode: 'markers',
				type: 'scatter',
				name: 'USDJPY'
		}]        
        
        
		var selected = 'USDTRY';
		const res4 = data.filter(({
		  Symbol
		}) => selected.includes(Symbol));
		var trace5 = [{
				x: res4.map((column) => column.LP),
				y: res4.map((column) => column.SpreadPnLPM),
                mode: 'markers',
				type: 'scatter',
				name: 'USDTRY'
		}]    
    
		var char_data = trace1.concat(trace4, trace2, trace3, trace5); 
		
		var layout = {
					title: 'SpreadPnL by Symbol',
					showlegend: true,
					width: 750,
					height: 500,
                    xaxis: {
                        title: {
                          text: 'LP'
                          }
                        },
                  
                  yaxis: {
                    title: {
                      text: 'SpreadPnLPM'
                      }
                    }                       
                    
                    
					};


		var output_div = document.getElementById('chart1')
		Plotly.newPlot(output_div, char_data, layout, { margin: { t: 0 } },{displayModeBar: false})
		
	})
	
</script>
++++


===  Two categories (`eqx` function) 
---
`eqx` returns the variable if the input is equal to this variable and  `Other` if the equality is not satistfied. 

This can be utilised by RFS user to performance broker review style analysis. The analysis can be provided to the broker to show their own stats together with aggregated stats of all other brokers. This way you can hide proprietary details but provide broker with some information.

This can also be used by the LP to do internal analysis of one their account versus everything else.

====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex4.py[]
----
====

==== Results
---
image::api_rfs/execution_stats/api_rfs_execution_stats_ex4.png["api_rfs_execution_stats_ex4.png",400,100]



=== Two categories (`eq` masking) 
---
`eq` returns `True` or `False`, in contrast to the `eqx` returns the variable if `True` else Other if `False`.
This groups the dataset into two categories. Like the above example it can be used for broker review analysis.

====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex5.py[]
----
====

==== Results
---
image::api_rfs/execution_stats/api_rfs_execution_stats_ex5.png["api_rfs_execution_stats_ex5.png",400,100]


=== Percentile 
---
`percentile` returns the x percentile of the specified column.

In this example we return the value corresponding to the 25th, 50th, 75th, 90th and 100th percentile of `SpreadPnLPM`.
You can query various percentiles in the `select` parameter and analyse distribution of the chosen metric.

**Warning**: This function is computationally intensive running on a large data set will results in a slower response time.

====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex6.py[]
----
====

==== Results
---
image::api_rfs/execution_stats/api_rfs_execution_stats_ex6.png["api_rfs_execution_stats_ex6.png"]

==== Figure
---

====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex6_fig.py[]
----
====

++++
<div id='chart2'></div>
<script>
	d3.csv("../_attachments/api_rfs/execution_stats/raw/api_rfs_execution_stats_ex6.csv").then((data) => {

		var trace1 = [{
				x: data.map((column) => column.LP),
				y: data.map((column) => column.SpreadPnLPM_Pct25),
				type: 'bar',
				name: 'SpreadPnLPM_Pct25'
		}]
  
		var trace2 = [{
				x: data.map((column) => column.LP),
				y: data.map((column) => column.SpreadPnLPM_Pct50),
				type: 'bar',
				name: 'SpreadPnLPM_Pct50'
		}]
    
		var trace3 = [{
				x: data.map((column) => column.LP),
				y: data.map((column) => column.SpreadPnLPM_Pct75),
				type: 'bar',
				name: 'SpreadPnLPM_Pct75'
		}]
        
		var trace4 = [{
				x: data.map((column) => column.LP),
				y: data.map((column) => column.SpreadPnLPM_Pct90),
				type: 'bar',
				name: 'SpreadPnLPM_Pct90'
		}]

		var trace5 = [{
				x: data.map((column) => column.LP),
				y: data.map((column) => column.SpreadPnLPM_Pct100),
				type: 'bar',
				name: 'SpreadPnLPM_Pct100'
		}]
        
		var char_data = trace1.concat(trace2, trace3, trace4, trace5); 
		
		var layout = {
					title: 'SpreadPnLPM Percentile Plot',
					showlegend: true,
					width: 750,
					height: 500,
                    xaxis: {
                        title: {
                          text: 'LP'
                          }
                        },
                  
                  yaxis: {
                    title: {
                      text: 'SpreadPnLPM'
                      }
                    }                      
					};


		var output_div = document.getElementById('chart2')
		Plotly.newPlot(output_div, char_data, layout, { margin: { t: 0 } },{displayModeBar: false})
		
	})
	
</script>
++++


=== Rank Percentile 
---
The `rank_percentile` function transforms the target column into a value in the range of [0;100].

This is applied in the `filter` option. The user can use this function to apply an outlier filtering. `DecayPM1s` results are filtered to only select values which fall within the 10th-90th percentile range.

**Warning**: This function is computationally intensive running on a large data set will results in a slower response time.

====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex7.py[]
----
====

==== Results
---
image::api_rfs/execution_stats/api_rfs_execution_stats_ex7.png["api_rfs_execution_stats_ex7.png",300,100]

==== Figure
---

====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex7_fig.py[]
----
====

++++
<div id='chart3'></div>
<script>
	d3.csv("../_attachments/api_rfs/execution_stats/raw/api_rfs_execution_stats_ex7.csv").then((data) => {

		var trace1 = [{
				x: data.map((column) => column.LP),
				y: data.map((column) => column.DecayPM1s),
				type: 'bar',
				name: 'DecayPM1s',
                transforms: [
                {
                type: 'sort',
                target: 'y',
                order: 'descending'
                }]                   
                
		}]
    
		var char_data = trace1; 
		
		var layout = {
					title: 'Rank Percentile Plot',
					showlegend: true,
					width: 750,
					height: 500,
                    xaxis: {
                        title: {
                          text: 'LP'
                          }
                        },
                  
                  yaxis: {
                    title: {
                      text: 'DecayPM1s'
                      }
                    }                        
					};


		var output_div = document.getElementById('chart3')
		Plotly.newPlot(output_div, char_data, layout, { margin: { t: 0 } },{displayModeBar: false})
		
	})
	
</script>
++++

=== Histogram (Buckets)
---

Group modification function `hist` (stands for histogram buckets) splits the incoming variable range (`DecayPM1m` in the below example) into a number of buckets of the same size.  Variables in the `select` operator are aggregated within those buckets. 

**Note**: The resulting column created by applying `hist` in the groupby, returns the middle value of the bucket.

====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex8.py[]
----
====

==== Results
---
image::api_rfs/execution_stats/api_rfs_execution_stats_ex8.png["api_rfs_execution_stats_ex8.png",400,100]

==== Figure
---

====
[source,python]
----
include::example$api_rfs/execution_stats/api_rfs_execution_stats_ex8_fig.py[]
----
====

++++
<div id='chart4'></div>
<script>
	d3.csv("../_attachments/api_rfs/execution_stats/raw/api_rfs_execution_stats_ex8.csv").then((data) => {

		var trace1 = [{
				x: data.map((column) => column.DecayPM1m),
				y: data.map((column) => column.Count),
				type: 'bar',
				name: 'Count'
		}]
  
		var char_data = trace1; 
		
		var layout = {
					title: 'Histogram DecayPM1m',
					showlegend: true,
					width: 750,
					height: 500,
                    xaxis: {
                        title: {
                          text: 'DecayPM1s'
                          }
                        },
                  
                  yaxis: {
                    title: {
                      text: 'Count'
                      }
                    }                                            
					};


		var output_div = document.getElementById('chart4')
		Plotly.newPlot(output_div, char_data, layout, { margin: { t: 0 } },{displayModeBar: false})
		
	})
	
</script>
++++


== Field Definitions

Refer to xref:analytics_rfs.adoc[Analytics RFS] page for details and formula.

[%header,format=csv]
|===
include::example$api_rfs/execution_stats/rfs_field_definitions_execution_stats.csv[]
|===


=== Aggreggation Functions (for `select` if `groupby` is present)
---

[%header,format=csv]
|===
include::example$api_rfs/execution_stats/rfs_field_definitions_execution_stats_agg_functions.csv[]
|===

=== Modification Functions (for `filter` and `groupby` )
---

[%header,format=csv]
|===
include::example$api_rfs/execution_stats/rfs_field_definitions_execution_stats_modif_function.csv[]
|===