= Bilateral Aggregates

== Introduction

The `v1_fx_rfs_bilateral-aggregates` endpoint returns anonymized data by masking the `LP` names. It can be used to create broker reviews. 

The endpoint is designed to study general aggregated execution quality of the trades and their associated market impact. For example, we show how you can use this endpoint to create a `LP` analysis. It includes the summarised spread paid and market impact generated by different liquidity providers split.

The query returns a table with the metrics (fields) selected by you as columns. The rows are defined by `groupby` statements. 

Refer to xref:analytics_bilateral_sharing.adoc[RFS Bilateral Sharing] page for details on how bilateral sharing works.

== API Specification

The API endpoint requires a JSON object representing query logic similar to SQL and containing the following fields:

* `groupby` - which fields the results will be aggregated by
* `select`  - which fields should be returned in the end result. For example `SpreadPnLPM`.  
* `filter`  - how the underlying data should be filtered

**Note:** This API endpoint is similar to the xref:api_rfs/api_rfs_execution_stats.adoc[v1/fx/rfs/execution-stats] endpoint. 
The difference is that this API endpoint sources aggregated data and masks the `LP` names.


== Example 
For more examples refer to xref:api_rfs/api_rfs_execution_stats.adoc[v1/fx/rfs/execution-stats]

**Note**: For display purposes we have limited the number of rows to 5 and and columns to 10.


===  LP Analysis -  Spread Paid and Market Impact
---

Refer to xref:api_rfs_bilateral/api_rfs_bilateral.adoc[RFS Bilateral API] page for page for details on aggregation logic.

In this example we conduct a `LP` analysis where we group the results by `LP`, `Symbol` and `OrderStatus` . This is to review the overall quality of the liquidity of each LP.
It is also important what the market does after fill. 

`DecayPM1s` measures side-adjusted move in $/m. 

Positive number means that that market mid goes up after buy fill and down after sell fill.
Groupingby `OrderStatus` allows you to differentiate the markout curves between filled and rejected trades.

====
[source,python]
----
include::example$api_rfs_bilateral/aggregates/api_rfs_bilateral_aggregates.py[]
----
====

==== Results
---
image::api_rfs_bilateral/aggregates/api_rfs_bilateral_aggregates_ex1.png["api_rfs_bilateral_aggregates_ex1.png"]

==== Figure
---

====
[source,python]
----
include::example$api_rfs_bilateral/aggregates/api_rfs_bilateral_aggregates_ex1_fig.py[]
----
====


++++
<div id='chart1'></div>
<script>
	d3.csv("../_attachments/api_rfs_bilateral/aggregates/raw/api_rfs_bilateral_aggregates_ex1.csv").then((data) => {
    
		var selected = 'USDJPY';
		const res = data.filter(({
		  Symbol
		}) => selected.includes(Symbol));
        
		var selected = 'F';
		const fills_data = res.filter(({
		  OrderStatus
		}) => selected.includes(OrderStatus));
    

		var trace1 = [{
				x: fills_data.map((column) => column.LP),
				y: fills_data.map((column) => column.DecayPM30s),
				type: 'bar',
				name: 'DecayPM30s',
                transforms: [{
                    type: 'sort',
                    target: 'y',
                    order: 'descending'
                    }]
		}]
        


		var char_data = trace1; 
		
		var layout = {
					title: 'Filled Trades: USDJPY DecayPM30s by LP',
					showlegend: true,
					width: 750,
					height: 500,
                    xaxis: {
                        title: {
                          text: 'LP'
                          }
                        },
                  
                  yaxis: {
                    title: {
                      text: 'DecayPM30s'
                      }
                    }                       

					};


		var output_div = document.getElementById('chart1')
		Plotly.newPlot(output_div, char_data, layout, { margin: { t: 0 } },{displayModeBar: false})
		
	})
	
</script>
++++



++++
<div id='chart2'></div>
<script>
	d3.csv("../_attachments/api_rfs_bilateral/aggregates/raw/api_rfs_bilateral_aggregates_ex1.csv").then((data) => {
    
		var selected = 'USDJPY';
		const res = data.filter(({
		  Symbol
		}) => selected.includes(Symbol));
        

		var selected = 'R';
		const rej_data = res.filter(({
		  OrderStatus
		}) => selected.includes(OrderStatus));        


		var trace1 = [{
				x: rej_data.map((column) => column.LP),
				y: rej_data.map((column) => column.DecayPM30s),
				type: 'bar',
				name: 'DecayPM30s',
                transforms: [{
                    type: 'sort',
                    target: 'y',
                    order: 'descending'
                    }]
		}]


		var char_data = trace1; 
		
		var layout = {
					title: 'Rejected Trades :USDJPY DecayPM30s by LP',
					showlegend: true,
					width: 750,
					height: 500,
                    xaxis: {
                        title: {
                          text: 'LP'
                          }
                        },
                  
                  yaxis: {
                    title: {
                      text: 'DecayPM30s'
                      }
                    }                       
                    
					};


		var output_div = document.getElementById('chart2')
		Plotly.newPlot(output_div, char_data, layout, { margin: { t: 0 } },{displayModeBar: false})
		
	})
	
</script>
++++

== Field Definitions
Refer to xref:analytics_rfs.adoc[Analytics RFS] page for details and formula.

[%header,format=csv]
|===
include::example$api_rfs_bilateral/aggregates/rfs_bilateral_field_definitions_aggs.csv[]
|===


=== Aggreggation Functions (for `select` if `groupby` is present)
---

[%header,format=csv]
|===
include::example$api_rfs/execution_stats/rfs_field_definitions_execution_stats_agg_functions.csv[]
|===

=== Modification Functions (for `filter` and `groupby` )
---

[%header,format=csv]
|===
include::example$api_rfs/execution_stats/rfs_field_definitions_execution_stats_modif_function.csv[]
|===